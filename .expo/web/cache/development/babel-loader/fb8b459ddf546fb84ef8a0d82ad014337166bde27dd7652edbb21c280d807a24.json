{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar cross_spawn_1 = __importDefault(require(\"cross-spawn\"));\nfunction spawnAsync(command, args) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var fakeErr = new Error('fake error just to preserve stacktrace');\n  var previousStack = fakeErr.stack && fakeErr.stack.split('\\n').splice(1);\n  var previousStackString = previousStack && ['    ...'].concat(_toConsumableArray(previousStack)).join('\\n');\n  var child;\n  var promise = new Promise(function (resolve, reject) {\n    var ignoreStdio = options.ignoreStdio,\n      nodeOptions = __rest(options, [\"ignoreStdio\"]);\n    child = cross_spawn_1.default(command, args, nodeOptions);\n    var stdout = '';\n    var stderr = '';\n    if (!ignoreStdio) {\n      if (child.stdout) {\n        child.stdout.on('data', function (data) {\n          stdout += data;\n        });\n      }\n      if (child.stderr) {\n        child.stderr.on('data', function (data) {\n          stderr += data;\n        });\n      }\n    }\n    var completionListener = function completionListener(code, signal) {\n      child.removeListener('error', errorListener);\n      var result = {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout: stdout,\n        stderr: stderr,\n        status: code,\n        signal: signal\n      };\n      if (code !== 0) {\n        var error = signal ? new Error(`${command} exited with signal: ${signal}`) : new Error(`${command} exited with non-zero code: ${code}`);\n        if (error.stack && previousStackString) {\n          error.stack += `\\n${previousStackString}`;\n        }\n        Object.assign(error, result);\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    };\n    var errorListener = function errorListener(error) {\n      if (ignoreStdio) {\n        child.removeListener('exit', completionListener);\n      } else {\n        child.removeListener('close', completionListener);\n      }\n      Object.assign(error, {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout: stdout,\n        stderr: stderr,\n        status: null,\n        signal: null\n      });\n      reject(error);\n    };\n    if (ignoreStdio) {\n      child.once('exit', completionListener);\n    } else {\n      child.once('close', completionListener);\n    }\n    child.once('error', errorListener);\n  });\n  promise.child = child;\n  return promise;\n}\nexports.default = spawnAsync;","map":{"version":3,"names":["cross_spawn_1","__importDefault","require","spawnAsync","command","args","options","arguments","length","undefined","fakeErr","Error","previousStack","stack","split","splice","previousStackString","concat","_toConsumableArray","join","child","promise","Promise","resolve","reject","ignoreStdio","nodeOptions","__rest","default","stdout","stderr","on","data","completionListener","code","signal","removeListener","errorListener","result","pid","output","status","error","Object","assign","once","exports"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\spawn-async\\src\\spawnAsync.ts"],"sourcesContent":["import { ChildProcess, SpawnOptions as NodeSpawnOptions } from 'child_process';\nimport spawn from 'cross-spawn';\n\nexport interface SpawnOptions extends NodeSpawnOptions {\n  ignoreStdio?: boolean;\n}\n\nexport interface SpawnPromise<T> extends Promise<T> {\n  child: ChildProcess;\n}\n\nexport interface SpawnResult {\n  pid: number;\n  output: string[];\n  stdout: string;\n  stderr: string;\n  status: number | null;\n  signal: string | null;\n}\n\nexport default function spawnAsync(\n  command: string,\n  args?: ReadonlyArray<string>,\n  options: SpawnOptions = {}\n): SpawnPromise<SpawnResult> {\n  const fakeErr = new Error('fake error just to preserve stacktrace');\n  const previousStack = fakeErr.stack && fakeErr.stack.split('\\n').splice(1);\n  const previousStackString = previousStack && ['    ...', ...previousStack].join('\\n');\n\n  let child: ChildProcess;\n  let promise = new Promise((resolve, reject) => {\n    let { ignoreStdio, ...nodeOptions } = options;\n    // @ts-ignore: cross-spawn declares \"args\" to be a regular array instead of a read-only one\n    child = spawn(command, args, nodeOptions);\n    let stdout = '';\n    let stderr = '';\n\n    if (!ignoreStdio) {\n      if (child.stdout) {\n        child.stdout.on('data', data => {\n          stdout += data;\n        });\n      }\n\n      if (child.stderr) {\n        child.stderr.on('data', data => {\n          stderr += data;\n        });\n      }\n    }\n\n    let completionListener = (code: number | null, signal: string | null) => {\n      child.removeListener('error', errorListener);\n      let result: SpawnResult = {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout,\n        stderr,\n        status: code,\n        signal,\n      };\n      if (code !== 0) {\n        let error = signal\n          ? new Error(`${command} exited with signal: ${signal}`)\n          : new Error(`${command} exited with non-zero code: ${code}`);\n        if (error.stack && previousStackString) {\n          error.stack += `\\n${previousStackString}`;\n        }\n        Object.assign(error, result);\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    };\n\n    let errorListener = (error: Error) => {\n      if (ignoreStdio) {\n        child.removeListener('exit', completionListener);\n      } else {\n        child.removeListener('close', completionListener);\n      }\n      Object.assign(error, {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout,\n        stderr,\n        status: null,\n        signal: null,\n      });\n      reject(error);\n    };\n\n    if (ignoreStdio) {\n      child.once('exit', completionListener);\n    } else {\n      child.once('close', completionListener);\n    }\n    child.once('error', errorListener);\n  }) as SpawnPromise<SpawnResult>;\n  // @ts-ignore: TypeScript isn't aware the Promise constructor argument runs synchronously and\n  // thinks `child` is not yet defined\n  promise.child = child;\n  return promise;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}