{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearUnusedCachesAsync = exports.cacheImageAsync = exports.getImageFromCacheAsync = exports.ensureCacheDirectory = exports.createCacheKeyWithDirectoryAsync = exports.createCacheKey = void 0;\nvar crypto_1 = __importDefault(require(\"crypto\"));\nvar fs_extra_1 = require(\"fs-extra\");\nvar path_1 = require(\"path\");\nvar CACHE_LOCATION = '.expo/web/cache/production/images';\nvar cacheKeys = {};\nfunction calculateHash(filePath) {\n  var contents = filePath.startsWith('http') ? filePath : (0, fs_extra_1.readFileSync)(filePath);\n  return crypto_1.default.createHash('sha256').update(contents).digest('hex');\n}\nfunction createCacheKey(fileSource, properties) {\n  var hash = calculateHash(fileSource);\n  return [hash].concat(properties).filter(Boolean).join('-');\n}\nexports.createCacheKey = createCacheKey;\nfunction createCacheKeyWithDirectoryAsync(_x, _x2, _x3) {\n  return _createCacheKeyWithDirectoryAsync.apply(this, arguments);\n}\nfunction _createCacheKeyWithDirectoryAsync() {\n  _createCacheKeyWithDirectoryAsync = _asyncToGenerator(function* (projectRoot, type, icon) {\n    var cacheKey = `${type}-${createCacheKey(icon.src, [icon.resizeMode, icon.backgroundColor])}`;\n    if (!(cacheKey in cacheKeys)) {\n      cacheKeys[cacheKey] = yield ensureCacheDirectory(projectRoot, type, cacheKey);\n    }\n    return cacheKey;\n  });\n  return _createCacheKeyWithDirectoryAsync.apply(this, arguments);\n}\nexports.createCacheKeyWithDirectoryAsync = createCacheKeyWithDirectoryAsync;\nfunction ensureCacheDirectory(_x4, _x5, _x6) {\n  return _ensureCacheDirectory.apply(this, arguments);\n}\nfunction _ensureCacheDirectory() {\n  _ensureCacheDirectory = _asyncToGenerator(function* (projectRoot, type, cacheKey) {\n    var cacheFolder = (0, path_1.join)(projectRoot, CACHE_LOCATION, type, cacheKey);\n    yield (0, fs_extra_1.ensureDir)(cacheFolder);\n    return cacheFolder;\n  });\n  return _ensureCacheDirectory.apply(this, arguments);\n}\nexports.ensureCacheDirectory = ensureCacheDirectory;\nfunction getImageFromCacheAsync(_x7, _x8) {\n  return _getImageFromCacheAsync.apply(this, arguments);\n}\nfunction _getImageFromCacheAsync() {\n  _getImageFromCacheAsync = _asyncToGenerator(function* (fileName, cacheKey) {\n    try {\n      return yield (0, fs_extra_1.readFile)((0, path_1.resolve)(cacheKeys[cacheKey], fileName));\n    } catch (_unused) {\n      return null;\n    }\n  });\n  return _getImageFromCacheAsync.apply(this, arguments);\n}\nexports.getImageFromCacheAsync = getImageFromCacheAsync;\nfunction cacheImageAsync(_x9, _x10, _x11) {\n  return _cacheImageAsync.apply(this, arguments);\n}\nfunction _cacheImageAsync() {\n  _cacheImageAsync = _asyncToGenerator(function* (fileName, buffer, cacheKey) {\n    try {\n      yield (0, fs_extra_1.writeFile)((0, path_1.resolve)(cacheKeys[cacheKey], fileName), buffer);\n    } catch (_ref) {\n      var message = _ref.message;\n      console.warn(`Error caching image: \"${fileName}\". ${message}`);\n    }\n  });\n  return _cacheImageAsync.apply(this, arguments);\n}\nexports.cacheImageAsync = cacheImageAsync;\nfunction clearUnusedCachesAsync(_x12, _x13) {\n  return _clearUnusedCachesAsync.apply(this, arguments);\n}\nfunction _clearUnusedCachesAsync() {\n  _clearUnusedCachesAsync = _asyncToGenerator(function* (projectRoot, type) {\n    var cacheFolder = (0, path_1.join)(projectRoot, CACHE_LOCATION, type);\n    yield (0, fs_extra_1.ensureDir)(cacheFolder);\n    var currentCaches = (0, fs_extra_1.readdirSync)(cacheFolder);\n    if (!Array.isArray(currentCaches)) {\n      console.warn('Failed to read the icon cache');\n      return;\n    }\n    var deleteCachePromises = [];\n    for (var cache of currentCaches) {\n      if (cache.startsWith('.')) {\n        continue;\n      }\n      if (!(cache in cacheKeys)) {\n        deleteCachePromises.push((0, fs_extra_1.remove)((0, path_1.join)(cacheFolder, cache)));\n      }\n    }\n    yield Promise.all(deleteCachePromises);\n  });\n  return _clearUnusedCachesAsync.apply(this, arguments);\n}\nexports.clearUnusedCachesAsync = clearUnusedCachesAsync;","map":{"version":3,"names":["crypto_1","__importDefault","require","fs_extra_1","path_1","CACHE_LOCATION","cacheKeys","calculateHash","filePath","contents","startsWith","readFileSync","default","createHash","update","digest","createCacheKey","fileSource","properties","hash","concat","filter","Boolean","join","exports","createCacheKeyWithDirectoryAsync","_x","_x2","_x3","_createCacheKeyWithDirectoryAsync","apply","arguments","_asyncToGenerator","projectRoot","type","icon","cacheKey","src","resizeMode","backgroundColor","ensureCacheDirectory","_x4","_x5","_x6","_ensureCacheDirectory","cacheFolder","ensureDir","getImageFromCacheAsync","_x7","_x8","_getImageFromCacheAsync","fileName","readFile","resolve","_unused","cacheImageAsync","_x9","_x10","_x11","_cacheImageAsync","buffer","writeFile","_ref","message","console","warn","clearUnusedCachesAsync","_x12","_x13","_clearUnusedCachesAsync","currentCaches","readdirSync","Array","isArray","deleteCachePromises","cache","push","remove","Promise","all"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\image-utils\\src\\Cache.ts"],"sourcesContent":["import crypto from 'crypto';\nimport { ensureDir, readdirSync, readFile, readFileSync, remove, writeFile } from 'fs-extra';\nimport { join, resolve } from 'path';\n\nimport { ImageOptions } from './Image.types';\n\nconst CACHE_LOCATION = '.expo/web/cache/production/images';\n\nconst cacheKeys: { [key: string]: string } = {};\n\n// Calculate SHA256 Checksum value of a file based on its contents\nfunction calculateHash(filePath: string): string {\n  const contents = filePath.startsWith('http') ? filePath : readFileSync(filePath);\n  return crypto.createHash('sha256').update(contents).digest('hex');\n}\n\n// Create a hash key for caching the images between builds\nexport function createCacheKey(fileSource: string, properties: string[]): string {\n  const hash = calculateHash(fileSource);\n  return [hash].concat(properties).filter(Boolean).join('-');\n}\n\nexport async function createCacheKeyWithDirectoryAsync(\n  projectRoot: string,\n  type: string,\n  icon: ImageOptions\n): Promise<string> {\n  const cacheKey = `${type}-${createCacheKey(icon.src, [icon.resizeMode, icon.backgroundColor])}`;\n  if (!(cacheKey in cacheKeys)) {\n    cacheKeys[cacheKey] = await ensureCacheDirectory(projectRoot, type, cacheKey);\n  }\n\n  return cacheKey;\n}\n\nexport async function ensureCacheDirectory(\n  projectRoot: string,\n  type: string,\n  cacheKey: string\n): Promise<string> {\n  const cacheFolder = join(projectRoot, CACHE_LOCATION, type, cacheKey);\n  await ensureDir(cacheFolder);\n  return cacheFolder;\n}\n\nexport async function getImageFromCacheAsync(\n  fileName: string,\n  cacheKey: string\n): Promise<null | Buffer> {\n  try {\n    return await readFile(resolve(cacheKeys[cacheKey], fileName));\n  } catch {\n    return null;\n  }\n}\n\nexport async function cacheImageAsync(\n  fileName: string,\n  buffer: Buffer,\n  cacheKey: string\n): Promise<void> {\n  try {\n    await writeFile(resolve(cacheKeys[cacheKey], fileName), buffer);\n  } catch ({ message }) {\n    console.warn(`Error caching image: \"${fileName}\". ${message}`);\n  }\n}\n\nexport async function clearUnusedCachesAsync(projectRoot: string, type: string): Promise<void> {\n  // Clean up any old caches\n  const cacheFolder = join(projectRoot, CACHE_LOCATION, type);\n  await ensureDir(cacheFolder);\n  const currentCaches = readdirSync(cacheFolder);\n\n  if (!Array.isArray(currentCaches)) {\n    console.warn('Failed to read the icon cache');\n    return;\n  }\n  const deleteCachePromises: Promise<void>[] = [];\n  for (const cache of currentCaches) {\n    // skip hidden folders\n    if (cache.startsWith('.')) {\n      continue;\n    }\n\n    // delete\n    if (!(cache in cacheKeys)) {\n      deleteCachePromises.push(remove(join(cacheFolder, cache)));\n    }\n  }\n\n  await Promise.all(deleteCachePromises);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}